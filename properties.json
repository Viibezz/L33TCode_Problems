[
    {
        "title": "Insertion Sort",
        "pattern": "Sorting",
        "detail": "Stable & In-Place.",
        "level": "Easy",
        "notes": "Cards. The idea of an insertion sort is this: initially, only the first item is considered sorted. Then, for each item in the sequence, we insert that item into the sorted list by swapping that item with the item before it until the item before it is smaller than the current item. Move right num to the left until left num is smaller than right num. for each num[i], store i in variable curr, while curr>0 and num[curr-1]>num[curr]: swap curr and curr-1, then curr-=1 to move to left and repeat. return array",
        "time" : "O(n * (n-1) / 2) -> O(n^2) because two loops",
        "space": "O(1)"
    },
    {
        "title": "Selection Sort",
        "pattern": "Sorting",
        "detail": "Not Stable & In-Place.",
        "level": "Easy",
        "notes": "The idea for this sorting algorithm is that during each cycle, we find the smallest item from the unsorted pile and add it to the sorted pile. To find the smallest element in the unsorted pile, we have a temporary variable keeping track of the index to the smallest element. We then compare each element in the unsorted pile to that element, updating the new index if necessary. After all the elements have been compared, we swap the smallest index with the first index of the unsorted pile. The element is now part of the sorted pile. store variable min_index = i. compare min_index with all nums to the right, if num < min_index, min_index = j. swap min_index and j values. return array",
        "time" : "O(n * (n-1) / 2) -> O(n^2) because two loops",
        "space": "O(1)"
    },
    {
        "title": "Bubble Sort",
        "pattern": "Sorting",
        "detail": "Stable & In-Place.",
        "level": "Easy",
        "notes": "The idea of bubble sort is this: for each pass, we use a pointer to point at the first element of the list. For each cycle, we compare it to the next element in the list and swap them if the current item is greater, then move the pointer by one until it reaches the end of the list. We repeat this process until the list becomes sorted. The list is sorted if, during a pass, no swapping occurs. Note that during each pass, the largest element will always float to the top, like a bubble. Therefore, each pass, we only need to consider the interval excluding the last element of the previous interval, and the list is guaranteed to be sorted within n passes.",
        "time" : "O(n * (n-1) / 2) -> O(n^2) because two loops",
        "space": "O(1)"
    },
    {
        "title": "Merge Sort",
        "pattern": "Sorting",
        "level": "Medium",
        "detail": "Stable but Not In-Place. Assuming the sorting of the divided list is stable, the overall algorithm is stable, because if an element appears before another element with the same value, there are two situations. If they are in the same list, the first element is before the second one in that list, and the first one will be inserted first. If they are in different lists, the first element will be inserted first if two elements are equal. Note that the base case, where only one element exists in the list, is stable (because there are no two elements of the same size), so merge sort is stable. However, merge sort is not in-place because of the usage of additional arrays.",
        "notes": "The idea of a merge sort is divide and conquer: We divide the array into two almost equally, sort them (usually another merge sort), and merge the two sorted list into one. To merge the two sorted list, have two pointers point towards the bottom of the two list, and each step, add the smaller element from those two into the list and move the pointer of that item up by one until elements from both lists are fully added.",
        "time" : " O(nlog(n)) because for each item in the list, it is merged a number of times equal to the number of divisions to make to divide the list to a size of one, which is O(log(n)) times.",
        "space": "O(n)"
    },
    {
        "title": "Quick Sort",
        "pattern": "Sorting",
        "level": "Medium",
        "detail": "Not Stable & In-Place. This algorithm is not stable, as each swap skips a lot of values. It does sort the array in-place, though, as it does not require additional data structures. ",
        "notes": "The idea of quick sort is this: We select an arbitrary element in the list (known as the pivot), and we swap the elements in the list into two sides: a side where all the elements are smaller than the pivot, and a side where all the elements are larger or equal to the pivot. After grouping them this way, we swap the pivot with the first element of the side that is larger or equal to the pivot. This way, each element to the left of the pivot is smaller than it, and each element on the right is larger or equal to it. Then we just need to sort the left interval and the right interval (using the same method), then the list would be sorted. This is the idea, but how would it grouped together? One of the ways to achieve this is that for the interval that we are sorting, we have a pointer point before the start and at the end (including the pivot). For each swap, we move the start pointer until we find an element larger or equal to the pivot (after the initial index), and move the end pointer until we find an element smaller or equal to the pivot (before the initial index). Then we can swap those two elements and restart the process. If those two pointers meet, we stop and then we can swap the pivot and the meeting point.",
        "time" : "O(n^2). On average, where the list is divided somewhere near the center each time, the time complexity is O(nlog(n)). However, in the worst case scenario, each interval to sort is one less than the current interval, which would make the time complexity O(n^2). This depends heavily on which pivot point you chooses: if you choose an end point as your pivot and the list is already sorted, it will reach this time complexity. Otherwise, the chance of this happening is very low.",
        "space": "O(logn) it uses recursion as its core logic, and the minimum recursion layers is equal to log(n)"
    },
    {
        "title": "Two Sum",
        "pattern": "Hashmap",
        "detail": "Hashmap and check for difference",
        "level": "Easy",
        "Given": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order.",
        "example": "input, nums = [2,7,11,15], target = 9 -> output, [0,1]",
        "bruteforce": "Since the problem asks for two elements that sum to target, we can simply try every pair of numbers and see if they sum to target. for i, for j, if i==j return i,j",
        "optimized" : "The key to the problem is that there is ALWAYS only one pair of numbers that sum to target. difference = target - nums[i], we maintain a list of records of all previous values and compare the difference to its ONLY pair with the map={num:index} which keeps the records. For hashmap, with the increase of the number of entries, the hashmap's space will increase linearly.",
        "notes": "r = target - nums[i], if r in map: return [i, m[r]], else m[nums[i]] = i",
        "time" : "bruteforce -> O(n^2), optimized-> O(n)",
        "space": "bruteforce -> O(1),   optimized-> O(n)"
    },
    {
        "title": "Two Sum Sorted",
        "pattern": "Two Pointers",
        "detail": "Opposite Direction",
        "level": "Medium",
        "Given": "Given an array of integers sorted in ascending order, find two numbers that add up to a given target. Return the indices of the two numbers in ascending order. You can assume elements in the array are unique and there is only one solution. Do this in O(n) time and with constant auxiliary space.",
        "example": "input, nums = [2,7,11,15], target = 9 -> output, [1,2]",
        "bruteforce": "Since the problem asks for two elements that sum to target, we can simply try every pair of numbers and see if they sum to target. ",
        "optimized" : "We noticed that the array is sorted. This means the smallest two sum we can get is the sum of the first two numbers, and the largest two sum we can get is the sum of the last two numbers, the middle point is the smallest number + largest number. From this point, we can compare with our target. ",
        "notes": "if nums[left] + nums[right] > target: right-=1, elif < target: left+=1, elif ==: return [left+1,right+1]",
        "time" : "bruteforce -> O(n^2), optimized-> O(n)",
        "space": "bruteforce -> O(1),   optimized-> O(1)"
    },
    {
        "title": "Remove Duplicates",
        "pattern": "Two Pointers",
        "detail": "Same Direction",
        "level": "Easy",
        "Given": "Given a sorted list of numbers, remove duplicates and return the new length. You must do this in-place and without using extra memory.",
        "example": "input, nums = [0,0,1,1,1,2,2] -> output, [0,1,2]",
        "bruteforce": "If we could use extra memory, we can easily solve this by going through the list once and using a hashset to record elements we have seen. But we are not allowed extra memory. ",
        "optimized" : "An important condition is that the numbers are sorted, which means the same numbers are next to each other. This means as we go through the list, once we see a number A we will see all occurrences of A together, and will not see A again after we see B. Using this key observation, we can devise a fast/slow pointer solution.",
        "notes": "if nums[slow] != nums[fast]: slow+=1 nums[slow] = nums[fast], return slow+1(because we start 0th index)",
        "time" : "bruteforce -> O(), optimized-> O(n)",
        "space": "bruteforce -> O(), optimized-> O(1)"
    },
    {
        "title": "Middle of the Linked List",
        "pattern": "Two Pointers",
        "detail": "Same Direction",
        "level": "Easy",
        "Given": "Given the head of a singly linked list, return the middle node of the linked list. If there are two middle nodes, return the second middle node.",
        "example": "input, head = [1,2,3,4,5,6] -> output, [4,5,6]",
        "bruteforce": "If it was an array, then we can get its length and middle element trivially. For a linked list, we have to traverse it to find its length l. We can find l by traversing the list once and then find the middle element by traversing it again and stop on the l/2th element.",
        "optimized" : "Is there any way to traverse only once? We can use two pointers, a fast pointer that moves 2 nodes at a time and a slow pointer that moves 1 node at a time. Since the speed of the fast pointer is 2x of the slow pointer, by the time the fast pointer reaches the end the slow pointer should be at exactly the middle of the list.",
        "notes": "slow=fast=head, while fast and fast.next: slow=slow.next fast=fast.next.next, return slow. (while fast because if list length is odd then the fast pointer reaches the last node. And fast.next is for if the list length is even, the fast pointer lands on null.)",
        "time" : "bruteforce -> O(n) using 2 loops, optimized-> O(n) using 1 loop",
        "space": "bruteforce -> O(1), optimized-> O(1)"
    },
    {
        "title": "Move Zeroes",
        "pattern": "Two Pointers",
        "detail": "Same Direction",
        "level": "Easy",
        "Given": "Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements. Do this in-place without copying an array.",
        "example": "input, nums = [0,1,0,3,12] -> output, [1,3,12,0,0]",
        "bruteforce": "The problem description asks us to do it in-place without extra data structure. There are only a couple of things we can do under these constraints - linear traversal or binary search. We can copy in-place using variable i=0 to beginning of nums. Then we fill the rest of nums with zeros. for num in nums, if num != 0: nums[i] = num  i+=1. while i<len(nums): nums[i] = 0, i+=1.",
        "optimized" : "We use slow and fast pointers. The fast one moves one element at a time and if the current element is 0, do nothing, if the current element is non-0, swap its element with slow pointer's element and move slow pointer. The slow pointer always points to the next 0 if there is one. The order of non-0 elements is preserved because the early one always gets swapped to the early 0s.",
        "notes": "(optimized fast pointer) if fast pointer is not a zero, swap slow with fast then slow+=1. (less optimized slow ptr) if slow==0 and fast!=0 then swap slow with fast then slow+=1, if slow!=0 then slow+=1.",
        "time" : "bruteforce -> O(n) using 2 loops, optimized-> O(n) using 1 loop",
        "space": "bruteforce -> O(1), optimized-> O(1)"
    },
    {
        "title": "Palindrome Number",
        "pattern": "Math",
        "detail": "math trick",
        "level": "Easy",
        "Given": "Given an integer x, return true if x is palindrome integer.",
        "example": "input, x = -121 -> output, false. From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.",
        "bruteforce": "The first idea that comes to mind is to convert the number into string, and check if the string is a palindrome, but this would require extra non-constant space for creating the string which is not allowed by the problem description.",
        "optimized" : "Second idea would be reverting the number itself, and then compare the number with original number, if they are the same, then the number is a palindrome. The reverse of the last half of the palindrome should be the same as the first half of the number, if the number is a palindrome. All negative numbers are not palindrome. Revert the last half of the number.",
        "notes": "if x<0 or (x>0 and x%10 == 0): return False, y=x, reverted=0, reverted+= x%10, reverted*=10, x//=10, if reverted=y || reverted//10 == y:True else:False. (reverted//10 because if the number is odd 12321, then we can ignore the middle digit since it'll always equal itself.) ",
        "time" : "bruteforce -> O(n), optimized-> O(logn(n)) we divided the input by 10 every iteration",
        "space": "bruteforce -> O(n), optimized-> O(1)"
    },
    {
        "title": "Valid Palindrome",
        "pattern": "Two Pointers",
        "detail": "Opposite Direction",
        "level": "Easy",
        "Given": "Determine whether a string is a palindrome. Ignore all non-alphanumerics.",
        "example": "input, A man, a plan, a canal: Panama -> output, true",
        "bruteforce": "An easier and less error-prone way is to filter the non-alphanumeric characters first and then validate palindromeness. The time complexity is still O(N). Although since strings are immutable in most mainstream languages, filtering requires allocating a new string so space complexity would be O(N) where N is the length of the string.",
        "optimized" : "This is a straightforward two-pointer problem. We have two pointers l and r starting from the leftmost and rightmost position and moving towards each other. At each step, if the elements they point to are the same we move each pointer one position towards each other. If the elements under the pointers are different at any step, then the string is not a palindrome.",
        "notes": "left and right pointers move into middle. If pointer isalnum() == false, move in, if pointers != eachother, return False, else keep moving in.",
        "time" : "bruteforce -> O(n), optimized-> O(n)",
        "space": "bruteforce -> O(n), optimized-> O(1)"
    },
    {
        "title": "Valid Parenthesis",
        "pattern": "Stack",
        "detail": "Stack",
        "level": "Easy",
        "Given": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.",
        "example": "input, -> output, true",
        "bruteforce": "",
        "optimized" : "",
        "notes": "we use a map {closing_parenthesis:opening_parenthesis} to check for brackets type and a stack pf_stack = ['E'] to maintain the order of open/close parenthesis and avoid empty stack errors then check if the element is an open parenthesis then we push to the stack otherwise it means it's a closing parenthesis so we check the value of the key/closing_parenthesis and if it matches with the right opening parenthesis then we pop the opening parenthesis otherwise it's not a valid match, then repeat the process. if we return and stack equals 1 then it's valid parenthesis otherwise it's been a case of open parenthesis not matching or not in order parenthesis.",
        "time" : "bruteforce -> O(), optimized-> O(n)",
        "space": "bruteforce -> O(), optimized-> O(n)"
    },
    {
        "title": "Find All Anagrams in a String",
        "pattern": "Two Pointers",
        "detail": "Sliding Window",
        "level": "Medium",
        "Given": "Given two strings s and p, return an array of all the start indices of p's anagrams in s. You may return the answer in any order. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
        "example": "input, s = cbaebabacd, p = abc -> output, [0,6]",
        "bruteforce": "-",
        "optimized": "This is a classical sliding window problem. The sliding window is maintained at the size of check, and we keep track of the number of each type of characters inside the window in a hashmap. Every cycle, we move the window to the right, pushing the rightmost character while popping the leftmost character. We check that at any given time, if the content of the set matches the character count of check, by definition, that substring is an anagram, and we can insert the index into the resulting list.",
        "notes": "initialize the starting window with the first substring, compare s to p, if equal hashmaps, append index 0 to output array. Now everytime, pop left index, add right index, compare hashmaps, if equal, add left to output array.",
        "time" : "bruteforce -> O(), optimized-> O(n)",
        "space": "bruteforce -> O(n), optimized-> O(n)"
    },
    {
        "title": "Longest Substring without Repeating Characters",
        "pattern": "Two Pointers",
        "detail": "Sliding Window",
        "level": "Medium",
        "Given": "Given a string s, find the length of the longest substring without repeating characters.",
        "example": "input, s = pwwkew -> output, 3",
        "bruteforce": "Brute force way is to check every single substring and count the ones with non-repeating characters. A substring is defined by a start index and an end index.",
        "optimized": "To improve on brute force, we have to skip unnecessary operations. For a substring starting with start that already contains one duplicate character we want to stop checking more substrings with start index. When this happens we want to increment start and look at next set of substrings. the variant is the characters inside the window being unique. We use a set to record what's in the window. And when we encounter a character that's already in the window, we want to move the left pointer until it goes past the last occurrence of that character",
        "notes": "hashmap slow=0 fast=0 output=0, while fast<len(s), if s[fast] in map, pop slow from map and increment slow, else, add s[fast] to map and increment fast. update output, if right-left>output:right-left:output.",
        "time" : "bruteforce -> O(n^2),optimized-> O(n)",
        "space": "bruteforce -> O(1),  optimized-> O(n)"
    },
    {
        "title": "3Sum",
        "pattern": "Two Pointers",
        "detail": "Sliding Window",
        "level": "Medium",
        "Given": "Given a list of integers, return a list containing all unique triplets in the list such that the sum of the triplet is zero. Each triplet must be sorted in ascending order, and the resulting list must be sorted lexicographically. Notice that the solution set must not contain duplicate triplets.",
        "example": "input, nums = [-1,0,1,2,-1,-4] -> output, [[-1,-1,2],[-1,0,1]]",
        "bruteforce": "3 loops",
        "optimized": "The original list is not sorted, so you need to sort it yourself. Instead of simply using two pointers doing one pass, we need three pointers, one normal pointer always going forward, and a pair of opposite pointers that gets reset after the first pointer is moved.  Each cycle, we move the pair of pointers and see if they sum up to 0 with the first pointer. If they are, they are a valid triplet of pointers. Otherwise we move the pair of pointers based on if the sum is greater or less than 0.",
        "notes": "2 loops, outer one for getting A, check for duplicates if i>0 and i==i-1: continue, inner one for doing two sum for B and C. if threeSum>0 then k-=1, elif threeSum<0 then j+=1, else if equal 0, append to output array, while j == j-1 and j<k: j+=1, to skip duplicates between B and C.",
        "time" : "bruteforce -> O(n^3), optimized-> O(n^2)",
        "space": "bruteforce -> O(n), optimized-> O(n)"
    },
    {
        "title": "Linked List Cycle",
        "pattern": "Two Pointers",
        "detail": "Same Direction",
        "level": "Easy",
        "Given": "Given head, the head of a linked list, determine if the linked list has a cycle in it. Return true if there is a cycle in the linked list. Otherwise, return false.",
        "example": "input, head = [3,2,0,-4] -> output, True at index 1",
        "bruteforce": "A simple solution would be to use a set to store the information. We store all the nodes we have been through and check if we have been there each time we move. However, a set is not constant memory.",
        "optimized": "Floyd's Cycle Finding Algorithm, also known as the Tortoise and Hare Algorithm. The idea is to have two pointers, the fast pointer (hare) moves at double speed of the slow pointer (tortoise). Each cycle, the tortoise moves once and the hare moves twice. The idea is that since the cycle must have integer size, when the tortoise and the hare are both in the cycle, their distance difference must also be an integer. Then, each cycle, because of their speed difference, the distance between them constantly reduces until they meet, in which case we know there is a cycle. However, if there is no cycle, they will never meet because the speed of the hare is always faster.",
        "notes": "tortoise and hare, slow and fast pointers. if slow meets fast pointer, return True, else return False.",
        "time": "bruteforce -> O(n), optimized-> O(n) Worst case we have, O(2n) as the small pointer moves around the entire array once.",
        "space": "bruteforce -> O(n), optimized-> O(1)"
    },
    {
        "title": "Linked List Cycle II",
        "pattern": "Two Pointers",
        "detail": "Same Direction",
        "level": "Medium",
        "Given": "Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null.",
        "example": "input, head = [3,2,0,-4] -> output, True at index 1",
        "bruteforce": "-",
        "optimized": "-",
        "notes": "same as finding middle node, if slow and fast do not meet then there's no cycle we return False, if slow and fast pointers meet, slow is reset to head, slow and fast move up by one until they meet again. Where they meet again will be the index of the cycle.",
        "time": "bruteforce -> O(), optimized-> O()",
        "space": "bruteforce -> O(), optimized-> O()"
    },
    {
        "title": "Subarray Sum",
        "pattern": "Prefix",
        "detail": "Prefix sums",
        "level": "Medium",
        "Given": "Given an array of integers and an integer target, find a subarray that sums to target and return the start and end indices of the subarray. It's guaranteed to have a unique solution.",
        "example": "input, nums = [1, -20, -3, 30, 5, 4], k = 7-> output, [1,3]",
        "bruteforce": "The brute force way is to find the sum of each subarray and compare it with the target. Let N be the number of elements in the array. There are N subarrays with size 1, N-1 subarrays with size 2 .. and 1 subarray with size N.",
        "optimized": "The sum of elements from index 0 to i is called the prefix sum. If we have the subarray sum for each index, we can find the sum of any subarray in constant time. the problem boils down to Two Sum. We keep a dictionary of prefix_sum: index while going through the array calculating prefix_sum. If at any point, prefix_sum - target is in the dictionary we have found our subarray.",
        "notes": "pointer and a hashmap. store prefix sum in map{pf_sum:index}, map={0:0} (to get subarray starting 0th index), for each element, pf_sum +=element, complement = pf_sum - k, if complement in map then return [map[complement], i], map[pf_sum] = i+1 ",
        "time": "bruteforce -> O(n^2), optimized-> O(n)",
        "space": "bruteforce -> O(1), optimized-> O(n)"
    },
    {
        "title": "Total Number of Subarrays That Sum To Target",
        "pattern": "Prefix",
        "detail": "Prefix sums sum:k frequency",
        "level": "Medium",
        "Given": "Find the total number of subarrays that sums up to target.",
        "example": "input, nums = [1 1 1] k = 2 -> output, 2",
        "bruteforce": "",
        "optimized": "using complement but pf_map={pf_sum:number of prefix sums that sums up to k}, initialize pf_map={0:1}(since empty array's sum is 0) count=0, if complement in pf_map: count += pf_map[complement], if pf_sum in pf_map: +=1, else =1. return count",
        "notes": "pointer and a hashmap {sum k: #of pf_sums that sums up to k}",
        "time" : "bruteforce -> O(n^2), optimized-> O(n)",
        "space": "bruteforce -> O(1), optimized-> O(n)"
    },
    {
        "title": "Continuous Subarray Sum",
        "pattern": "Prefix",
        "detail": "Prefix sums remainder index" ,
        "level": "Medium",
        "Given": "Given an integer array nums and an integer k, return true if nums has a continuous subarray of size **at least two** whose elements sum up to a multiple of k, or false otherwise. An integer x is a multiple of k if there exists an integer n such that x = n * k. 0 is always a multiple of k.",
        "example": "input, nums = [23,2,4,6,7], k = 6 -> output, true",
        "bruteforce": "-",
        "optimized": "-",
        "notes": "(A/B) = Q remainder R, m={remainder:index}, sum = 0 m = {0:-1} (in case nums is size 1 and first element is divisible by k), for each element, sum += nums[i] remain = sum % k, if remain not in m: m[remain] = i, elif: i - m[remain] > 1 (to satisfy length constraint of atleast two elements sums): return True. return False.",
        "time" : "bruteforce -> O(n^2), optimized-> O(n)",
        "space": "bruteforce -> O(1), optimized-> O(n)"
    },
    {
        "title": "Subarray Sum Divisible By k",
        "pattern": "Prefix",
        "detail": "Prefix sums remainder frequency",
        "level": "Medium",
        "Given": "Given an integer array nums and an integer k, return the number of non-empty subarrays that have a sum divisible by k.",
        "example": "input, nums = [4,5,0,-2,-3,1], k = 5 -> output, 7",
        "bruteforce": "-",
        "optimized": "-",
        "notes": "we use remainders and complement. pf_map = {remainder:frequency} = {0:1} for empty array we have 1, for each element, pf_sum += nums[i], r = (pf_sum - k) % k, if r in pf_map: count += pf_map[r], pf_map[r] = pf_map.get(r, 0) + 1, return count.",
        "time" : "bruteforce -> O(n^2), optimized-> O(n)",
        "space": "bruteforce -> O(1), optimized-> O(n)"
    },
    {
        "title": "Group Anagrams",
        "pattern": "Hashmap",
        "detail": "sort and store in hashmap",
        "level": "Medium",
        "Given": "Given an array of strings strs, group the anagrams together. You can return the answer in any order.",
        "example": "input, strs = [eat,tea,tan,ate,nat,bat]-> output, Output: [[bat],[nat,tan],[ate,eat,tea]]",
        "bruteforce": "-",
        "optimized": "-",
        "notes": "m={sorted_characters:[list of strings[i]]}, x = ''.join(sorted(strings[i])), if x not in m: m[x] = [strings[i]] else: m[x].append(strings[i]). return list(m.values())",
        "time" : "bruteforce -> O(), optimized-> O(n)",
        "space": "bruteforce -> O(), optimized-> O(n)"
    },
    {
        "title": "Top K Frequent Elements",
        "pattern": "Hashmap",
        "detail": "hashmap to count and list to store lists. ",
        "level": "Medium",
        "Given": "Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.",
        "example": "input, nums = [1,1,1,2,2,3], k = 2 -> output, [1,2]",
        "bruteforce": "use max heap. ",
        "optimized": "use bucket sort trick. initialize frequency list with list for each index + 1 (zero index will always be empty) frequency list will be count:values. initialize hashmap and store count of each num. for each item in map, value is frequency index and append the keys to it. initialize result list. traverse frequency list backwards, for each value in frequency count, append to result list, if result list equals k then return result list.",
        "notes": "",
        "time" : "bruteforce -> O(nlogn), optimized-> O(n)",
        "space": "bruteforce -> O(n), optimized-> O(n)"
    },
    {
        "title": "Product of Array Except Self",
        "pattern": "Hashmap",
        "detail": "Prefix multiplication",
        "level": "Medium",
        "Given": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].",
        "example": "input,nums = [1,2,3,4] -> output, [24,12,8,6]",
        "bruteforce": "-",
        "optimized": "-",
        "notes": "",
        "time" : "bruteforce -> O(), optimized-> O()",
        "space": "bruteforce -> O(), optimized-> O()"
    },
    {
        "title": "Count Number of Nice Subarrays",
        "pattern": "Prefix",
        "detail": "Prefix sums",
        "level": "Medium",
        "Given": "",
        "example": "input, -> output, ",
        "bruteforce": "-",
        "optimized": "-",
        "notes": "modify array to 1s if odd and 0s if even. initialize m{0:1} #pf_sum:frequency, y = pf_sum-k, if y in m: count+= m[y]. m[pf_sum] = counter",
        "time" : "bruteforce -> O(), optimized-> O(n)",
        "space": "bruteforce -> O(), optimized-> O(n)"
    },
    {
        "title": "Encode and Decode Strings",
        "pattern": "Hashmap",
        "detail": "",
        "level": "Medium",
        "Given": "Design an algorithm to encode a list of strings to a string. The encoded string is then sent over the network and is decoded back to the original list of strings. Please implement encode and decode",
        "example": "input, -> output, ",
        "bruteforce": "-",
        "optimized": "-",
        "notes": "",
        "time" : "bruteforce -> O(), optimized-> O()",
        "space": "bruteforce -> O(), optimized-> O()"
    },
    {
        "title": "Longest Consecutive Sequence",
        "pattern": "Hashmap",
        "detail": "",
        "level": "Medium",
        "Given": "Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence. You must write an algorithm that runs in O(n) time.",
        "example": "input, -> output, ",
        "bruteforce": "sort then count",
        "optimized": "-",
        "notes": "",
        "time" : "bruteforce -> O(), optimized-> O()",
        "space": "bruteforce -> O(), optimized-> O()"
    },
    {
        "title": "Valid Sudoku",
        "pattern": "Hashmap",
        "detail": "",
        "level": "Medium",
        "Given": "Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules",
        "example": "input, -> output, true",
        "bruteforce": "-",
        "optimized": "-",
        "notes": "",
        "time" : "bruteforce -> O(), optimized-> O(9*9)",
        "space": "bruteforce -> O(), optimized-> O(n)"
    },
    {
        "title": "Best Time to Buy and Sell Stock",
        "pattern": "Two Pointers",
        "detail": "Sliding Window",
        "level": "Easy",
        "Given": "You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.",
        "example": "input, prices = [7,1,5,3,6,4] -> output, 5",
        "bruteforce": "-",
        "optimized": "-",
        "notes": "",
        "time" : "bruteforce -> O(), optimized-> O(n)",
        "space": "bruteforce -> O(), optimized-> O(1)"
    },
    {
        "title": "Container With Most Water",
        "pattern": "Two Pointers",
        "detail": "return maxArea",
        "level": "Medium",
        "Given": "Find two lines that together with the x-axis form a container, such that the container contains the most water. Return the maximum amount of water a container can store.",
        "example": "input, height = [1,8,6,2,5,4,8,3,7] -> output, 49",
        "bruteforce": "we can check every i with j+i till the end, update the max the area ( (right-left) * min(height[left], height[right]) )",
        "optimized": "we can check the area, then update max, then shift left to the right or right to the left based on the shorter height side.",
        "notes": "",
        "time" : "bruteforce -> O(n^2), optimized-> O(n)",
        "space": "bruteforce -> O(1), optimized-> O(1)"
    },
    {
        "title": "Permutation in String",
        "pattern": "Two Pointers",
        "detail": "Sliding Window",
        "level": "Medium",
        "Given": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.",
        "example": "input, s1 = ab, s2 = eidbaooo -> output, true s2 contains one permutation of s1 (ba).",
        "bruteforce": "-",
        "optimized": "Same as longest without repeated characters but return boolean true/false",
        "notes": "",
        "time" : "bruteforce -> O(n^2), optimized-> O(n)",
        "space": "bruteforce -> O(n), optimized-> O(n)"
    },
    {
        "title": "Longest Repeating Character Replacement",
        "pattern": "Two Pointers",
        "detail": "Sliding Window",
        "level": "Medium",
        "Given": "You are given a string s and an integer k. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most k times. Return the length of the longest substring containing the same letter you can get after performing the above operations.",
        "example": "input, s = ABAB, k = 2 -> output, 4",
        "bruteforce": "-",
        "optimized": "-",
        "notes": "initialize counter hashmap m{s[i]:count}, for each character, increment map count and check if we've fulfilled k replacements so if (window length - count of character) > k then we've exceeded k times so decrement left and move it to next character. compare result/output variable with current window length so max(res, window Length) ",
        "time" : "bruteforce -> O(), optimized-> O()",
        "space": "bruteforce -> O(), optimized-> O()"
    },
    {
        "title": "Find Minimum in Rotated Sorted Array",
        "pattern": "Binary Search",
        "detail": "",
        "level": "Medium",
        "Given": "Given the sorted rotated array nums of unique elements, return the minimum element of this array.",
        "example": "input, nums = [3,4,5,1,2] -> output, 1",
        "bruteforce": "-",
        "optimized": "-",
        "notes": "",
        "time" : "bruteforce -> O(), optimized-> O(logn)",
        "space": "bruteforce -> O(), optimized-> O(1)"
    },
    {
        "title": "Search Rotated Sorted Array",
        "pattern": "Binary Search",
        "detail": "",
        "level": "Medium",
        "Given": "Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.",
        "example": "input, nums = [4,5,6,7,0,1,2], target = 0 -> output, 4 ",
        "bruteforce": "-",
        "optimized": "-",
        "notes": "",
        "time" : "bruteforce -> O(), optimized-> O(logn)",
        "space": "bruteforce -> O(), optimized-> O(1)"
    },
    {
        "title": "Search a 2D Matrix",
        "pattern": "Binary Search",
        "detail": "",
        "level": "Medium",
        "Given": "Write an efficient algorithm that searches for a value target in an m x n integer matrix matrix. This matrix has the following properties: 1) Integers in each row are sorted from left to right. 2) The first integer of each row is greater than the last integer of the previous row. ",
        "example": "input, matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3 -> output, true",
        "bruteforce": "-",
        "optimized": "-",
        "notes": "",
        "time" : "bruteforce -> O(), optimized-> O(logn)",
        "space": "bruteforce -> O(), optimized-> O(1)"
    },
    {
        "title": "",
        "pattern": "",
        "detail": "",
        "level": "",
        "Given": "",
        "example": "input, -> output, ",
        "bruteforce": "-",
        "optimized": "-",
        "notes": "",
        "time" : "bruteforce -> O(), optimized-> O()",
        "space": "bruteforce -> O(), optimized-> O()"
    }
]